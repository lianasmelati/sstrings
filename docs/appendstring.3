.\" Copyright 2005 by Pablo Yanez Trujillo <pabloy@pcpool.mathematik.uni-freiburg.de
.\" The safe Strings Library Version 1.0.5
.\" 
.\" This is free software. Please read the file ../COPYING if you
.\" want to use/edit/distribuite this source file.
.\" This source file is protected by the GNU GPL-2
.\" NOTE: There is NO  warranty; not even for MERCHANTABILITY or 
.\" FITNESS FOR A PARTICULAR PURPOSE.
.TH "APPENDSTRING" "3" "July 2005" "Version 1.0.5" "Linux Programmer's Manual -- Safe Strings Library"
.SH "NAME"
appendstring, appendnstring, stringappend, stringnappend - appending strings to safe strings
.SH "SYNOPSIS"
.B #include <sstrings.h>

.B Linking with -lsstrings
.sp
.BI "char *appendstring(char **"buffer ", const char *"string ");"
.br
.BI "char *appendnstring(char **"buffer ", const char *"string ", size_t "len ");"

.BI "char *stringappend(char **"buffer ", const char *"string ");"
.br
.BI "char *stringnappend(char **"buffer ", const char *"string ", size_t "len ");"
.SH "DESCRIPTION"
These functions append strings to "safe strings", it means then took the adress of a char* pointer which memeroy
was allocated with malloc/realloc and try to make this space bigger and concatenate the string.

If \fI*buffer\fR is a NULL pointer then necessary new space is allocated (with malloc) and the content of \fIstring\fR is
copied into this new allocated space. Id \fI*buffer\fR is not NULL then these functions try to make the allocated necessary space
bigger and then concatenate the string passed with \fIstring\fR. \fIstring\fR must be a 0-terminated string. \fBappendstring\fR and
\fBstringappend\fR are wrapper functions of \fBappendnstring\fR and \fBstringnappend\fR. These functions take a thrird parameter,
\fIlen\fR tell how many characters (not including the \0 of \fIstring\fR) must be copied. These 4 functions set the \0 bit
automatically.

If you want to generate an empty string (with new space allocated) then you must set \fI*buffer\fR to NULL, \fIstring\fR must be an
empty string (the pointer must not be NULL). If you use \fBappendnstring\fR or \fBstringnappend\fR then you must set \fIlen\fR to 0.

\fI*buffer\fR and \fI*string\fR may overlap, it means that the memory areas may overlap.
.SS "Returning value"
These functions return a pointer to the new allocated space which is \fI*buffer\fR. Note that this pointer may change and the content
of the string pointed by \fI*buffer\fR will change unless the function doesn't generate an error. NULL is returned when an error
ocurred and \fIss_errno\fR will be set to \fISS_NULL_BUFFER\fR or \fISS_NO_MEM\fI or \fISS_NO_EXPAND\fR.
.SS "Error values for ss_errno"
\fBss_errno\fR is set to \fISS_NULL_BUFFER\fR if \fIbuffer\fR or \fIstring\fR are NULL.

\fBss_errno\fR is set to \fISS_NO_MEM\fR when the memory reservation fails and \fIbuffer\fR is an empty string.

\fBss_errno\fR is set to \fISS_NO_EXPAND\fR when the memory reservation fails and \fIbuffer\fR is \fBnot\fR an empty string.
.SS "Note"
Avoid using the same variable when you use one of this functions. appendstring(&str, str); will work in most of the cases but if
realloc changes the adress then you will posibly get a segmentation fault!

.SH "NOTES"
You should always proofe that the functions doesn't return NULL. \fIss_errno\fR is declared in the libraray and doesn't need to
be declared by yourself, just use it. Like errno from errno.h you must set it to SS_NO_ERROR by yourself (when SS_NO_ERROR is a posible
value when the returning pointer is NULL).

You must always free you buffers by yourself, don't forget it!

Read \fBsstrings\fR(5) for a list of the constants.
.SH "EXAMPLE"
.RS
.nf
	#include <stdio.h>
	#include <sstrings.h>

	int main(void)
	{
		char* hw = NULL, *tmp;

		hw = appendstring(&hw, "World!");

		if(!hw)
		{
			/* the only case: SS_NO_MEM */
			fprintf(stderr, "You don't have enough memory\\n");
			return 1;
		}

		tmp = stringnappend(&hw, "Hello Dolly, this is Louis, Dolly ...", 6);

		if(!tmp)
		{
			/* the only case: SS_NO_EXPAND */
			fprintf(stderr, "You don't have enough memory\\n");
			free(hw);
                        return 1;
		}

		hw = tmp; /* if tmp != hw then the old content of hw is free'ed by stringnappend */

		printf("%s\\n", hw); /* output: Hello World! */

		free(hw);
		
		return 0;
	}
.fi
.RE
.SH "BUGS"
I don't know about any bugs. But I would be very happy to know one if you find one. Please report bugs at
pabloy@pcpool.mathematik.uni-freiburg.de
.SH "SEE ALSO"
.BR addchar (3)
.BR str2sstr (3)
