.\" Copyright 2005 by Pablo Yanez Trujillo <pabloy@pcpool.mathematik.uni-freiburg.de
.\" The safe Strings Library Version 1.0.5
.\" 
.\" This is free software. Please read the file ../COPYING if you
.\" want to use/edit/distribuite this source file.
.\" This source file is protected by the GNU GPL-2
.\" NOTE: There is NO  warranty; not even for MERCHANTABILITY or 
.\" FITNESS FOR A PARTICULAR PURPOSE.
.TH "SUBSSTR" "3" "July 2005" "Version 1.0.5" "Linux Programmer's Manual -- Safe Strings Library"
.SH "NAME"
subsstr, substr, subrstr - locate a substring
.SH "SYNOPSIS"
.B #include <sstrings.h>

.B Linking with -lsstrings
.sp
.BI "char *subsstr(char **"buffer ", size_t "pos ", size_t "len ");"
.br

.BI "char *substr(const char *"haystack ", const char *"needle ");"
.br
.BI "char *subrstr(const char *"haystack ", const char *"needle ");"
.SH "DESCRIPTION"
This functions locate a substring and return a pointer to the location. \fBsubsstr\fR take 3 parameters, the adress of a
"safe string" passed by \fIbuffer\fR, the position \fIpos\fR at which the substring begins and read \fIlen\fR characters.
The content if \fI*buffer\fR is changed, it contains only the substring determinated by \fIpso\fR and \fIlen\fR.

If \fIlen\fR is 0 and \fI*buffer\fR is NULL, then NULL will be returned and ss_errno set to SS_NO_ERROR. If \fIlen\fR is 0 and 
\fI*buffer\fR is not NULL then \fI*buffer\fR is returned. if \fI*buffer\fR is an empty string NULL will be returned and
ss_errno is set to SS_EMPTY_STR.

\fBsubstr\fR finds the first occurrence of the substring \fIneedle\fR in the string \fIhaysatck\fR and returns a pointer to the
new allocated memory containing the rest of the string with the substring. The terminating \\0 characters are not compared.

\fBsubrstr\fR finds the last occurrence of the substring \fIneedle\fR in the string \fIhaysatck\fR and returns a pointer to the
new allocated memory containing the rest of the string with the substring. The terminating \\0 characters are not compared.

Both functions return NULL if malloc fails, in this case ss_errno is set to SS_NO_MEM.

If \fIneedle\fR is not found in \fIhaystack\fR then NULL is returned and ss_errno is set to SS_NEEDLE_NOT_FOUND.
.SS "Returning Value"
A pointer to the new (re)allocated memory containing the substring.

.SS "Error values for ss_errno"
\fBss_errno\fR is set to \fISS_NULL_BUFFER\fR if \fIbuffer\fR is NULL.

\fBss_errno\fR is set to \fISS_NO_ERROR\fR if \fIlen\fR is zero and \fI*buffer\fR is NULL.

\fBss_errno\fR is set to \fISS_EMPTY_STRING\fR if \fI*buffer\fR is an empty string.


.SH "NOTES"
You should always proofe that the functions doesn't return NULL. \fIss_errno\fR is declared in the libraray and doesn't need to
be declared by yourself, just use it. Like errno from errno.h you must set it to SS_NO_ERROR by yourself (when SS_NO_ERROR is a posible
value when the returning pointer is NULL).

You must always free you buffers by yourself, don't forget it!

Read \fBsstrings\fR(5) for a list of the constants.
.SH "EXAMPLE"
.RS
.nf
	#include <stdio.h>
	#include <sstrings.h>
	
	int main(void)
	{
		char* hello = NULL, *tmp, *world1, *world2;
		char somestring[] = "Hello Dolly my world, this is Hello world and I love it!";
		char needle[] = "world";

		hello = appendstring(&hello, somestring);
		if(!hello)
		{
			fprintf(stderr, "You don't have enough memory\\n");
			return 1;
		}

		ss_errno = SS_NO_ERROR;

		tmp = subsstr(&hello, 30, 11);

		if(!tmp)
		{
			/* ss_errno may be SS_NULL_BUFFER,
                           SS_NO_ERROR (when str is NULL and len (12) is 0)
                           SS_EMPTY_STR when str is an empty string

                           but thos values aren't posible */

                        fprintf(stderr, "An unexpected error was produced\\n");
			free(hello);
			return 1;
		}

		hello = tmp;

		ss_errno = SS_NO_ERROR;

		world1 = substr(somestring, needle);

		if(!world1)
		{
			if(ss_errno == SS_NEEDLE_NOT_FOUND) fprintf(stderr, "needle not found\\n");
			else fprintf(stderr, "You don't have enough memory\\n");
			free(hello);
			return 1;
		}

		ss_errno = SS_NO_ERROR;
		world2 = subrstr(somestring, needle);

		if(!world2)
		{
			if(ss_errno == SS_NEEDLE_NOT_FOUND) fprintf(stderr, "needle not found\\n");
			else fprintf(stderr, "You don't have enough memory\\n");
			free(hello);
			free(world1);
			return 1;
		}

		printf("%s\\n%s\\n%s\\n", hello, world1, world2);

		/* output:
		
		   Hello world
		   world, this is Hello world and I love it!
		   world and I love it!

		*/

		free(hello);
		free(world1);
		free(world2);

		return 0;
	}
.fi
.RE
.SH "BUGS"
I don't know about any bugs. But I would be very happy to know one if you find one. Please report bugs at
pabloy@pcpool.mathematik.uni-freiburg.de
.SH "SEE ALSO"
.BR strrstr (3)
.BR delsstr (3)
.BR cutsstr (3)
.BR cutrsstr (3)
