.\" Copyright 2005 by Pablo Yanez Trujillo <pabloy@pcpool.mathematik.uni-freiburg.de
.\" The safe Strings Library Version 1.0.5
.\" 
.\" This is free software. Please read the file ../COPYING if you
.\" want to use/edit/distribuite this source file.
.\" This source file is protected by the GNU GPL-2
.\" NOTE: There is NO  warranty; not even for MERCHANTABILITY or 
.\" FITNESS FOR A PARTICULAR PURPOSE.
.TH "DELSSTR" "3" "July 2005" "Version 1.0.5" "Linux Programmer's Manual -- Safe Strings Library"
.SH "NAMES"
delsstr, cutsstr, cutrsstr - locate substring and delete it
.SH "SYNOPSIS
.B #include <sstrings.h>

.B Linking with -lsstrings
.sp
.BI "char *delsstr(char **"buffer ", size_t "pos ", size_t "len ");"

.BI "char *cutsstr(char **"buffer ", const char *"needle ");"
.br
.BI "char *cutrsstr(char **"buffer ", const char *"needle ");"
.SH "DESCRIPTION"
The functions locate a substring in \fI*buffer\fR and cut it from \fI*buffer\fR. \fIbuffer\fR is the adress of a "safe string".

\fBdelsstr\fR take 2 parameters that determinate the position\fIpos\fR of the substring and the length \fIlen\fR of the substring.

In case of \fIcutsstr\fR and \fIcutrsstr\fR the string passed by \fIneedle\fR determinates which substring must be searched.

\fIcutsstr\fR finds the first occurence of \fIneedle\fR id \fI*buffer\fR (\\0 not compared) and the substring is cutted (if found)
from \fI*buffer\fR, then the function tries to resize the buffer to the needed space and returns a pointer to the new resized
memory.

\fIcutrsstr\fR finds the last occurence of \fIneedle\fR id \fI*buffer\fR (\\0 not compared) and the substring is cutted (if found)
from \fI*buffer\fR, then the function tries to resize the buffer to the needed space and returns a pointer to the new resized
memory.

Both functions are wrapper functions of \fBdelsstr\fR.
.SS "Returning Value"
The functions return a pointer to new resized memory saved in \fI*buffer\fR. If the substring is not found then NULL is returned and
ss_errno set to SS_NEEDLE_NOT_FOUND.

.SS "Error values for ss_errno"
\fBss_errno\fR is set to \fISS_NULL_BUFFER\fR if \fIbuffer\fR or \fIneedle\fR are NULL.

\fBss_errno\fR is set to \fISS_NEEDLE_NOT_FOUND\fR if \fIneedle\fR is not found in \fIbuffer\fR.

.SH "NOTES"
You should always proofe that the functions doesn't return NULL. \fIss_errno\fR is declared in the libraray and doesn't need to
be declared by yourself, just use it. Like errno from errno.h you must set it to SS_NO_ERROR by yourself (when SS_NO_ERROR is a posible
value when the returning pointer is NULL).

You must always free you buffers by yourself, don't forget it!

Read \fBsstrings\fR(5) for a list of the constants.
.SH "EXAMPLE"
.RS
.nf
	#include <stdio.h>
	#include <sstrings.h>

	int main(void)
	{
		char* test1 = NULL, *test2 = NULL, *test3 = NULL, *tmp;
		char somestring[] = "Hello my world, I want to be here in my world forever";
		char needle[] = "world";

		test1 = appendstring(&test1, somestring);

		if(!test1)
		{
			fprintf(stderr, "You don't have enough memory\\n");
			return 1;
		}

		test2 = appendstring(&test2, somestring);

		if(!test2)
		{
			fprintf(stderr, "You don't have enough memory\\n");
			free(test1);
			return 1;
		}

		test3 = appendstring(&test3, somestring);

		if(!test3)
		{
			fprintf(stderr, "You don't have enough memory\\n");
			free(test1);
			free(test3);
			return 1;
		}

		tmp = delsstr(&test1, 5, 9);

		if(!tmp)
		{
			fprintf(stderr, "You don't have enough memory\\n");
			free(test1);
			free(test2);
			free(test3);
			return 1;
		}

		test1 = tmp;

		tmp = cutsstr(&test2, needle);

		if(!tmp)
		{
			fprintf(stderr, "You don't have enough memory\\n");
			free(test1);
			free(test2);
			free(test3);
			return 1;
			
		}

		test2 = tmp;

		tmp = cutrsstr(&test3, needle);

		if(!tmp)
		{
			fprintf(stderr, "You don't have enough memory\\n");
 			free(test1);
 			free(test2);
 			free(test3);
  			return 1;

		}

 		test3 = tmp;

		printf("%s\\n%s\\n%s\\n", test1, test2, test3);

		/* output

		   Hello, I want to be here in my world forever
		   Hello my , I want to be here in my world forever
		   Hello my world, I want to be here in my  forever

		*/

		free(test1);
		free(test2);
		free(test3);

		return 0;
	}
.fi
.RE
.SH "BUGS"
I don't know about any bugs. But I would be very happy to know one if you find one. Please report bugs at
pabloy@pcpool.mathematik.uni-freiburg.de
.SH "SEE ALSO"
.BR substr (3)
.BR subrstr (3)
.BR ltrim (3)
.BR rtrim (3)
.BR trim (3)
.BR sstrltrim (3)
.BR sstrrtrim (3)
.BR sstrtrim (3)
