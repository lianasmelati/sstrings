.\" Copyright 2005 by Pablo Yanez Trujillo <pabloy@pcpool.mathematik.uni-freiburg.de
.\" The safe Strings Library Version 0.0.1
.\" 
.\" This is free software. Please read the file ../COPYING if you
.\" want to use/edit/distribuite this source file.
.\" This source file is protected by the GNU GPL-2
.\" NOTE: There is NO  warranty; not even for MERCHANTABILITY or 
.\" FITNESS FOR A PARTICULAR PURPOSE.
.TH "ADDCHAR" "3" "Februar 2005" "Version 0.0.1" "Linux Programmer's Manual -- Safe Strings Library"
.SH "NAME"
addchar - character addition to strings
.SH SYNOPSIS
.B #include <sstrings.h>
.sp
.BI "char *addchar(char **" buffer ", int "c ");"
.SH DESCRIPTION
This function adds a new character to a C string. buffer is a double pointer because the space is each time
reallocated and the adress may change.
.SS "Return Value"
If \fIbuffer\fR is NULL then the function will return NULL and \fIss_errno\fR is set to \fISS_NULL_BUFFER\fR.

If \fI*buffer\fR is NULL then the function will allocate 2 bytes (for the character and \0), set *buffer to the new
allocated space and returns a pointer to *buffer. If there is no memory left and malloc fails then NULL will be
returned and ss_errno will be set to \fISS_NO_MEM\fR.

The returning pointers contains a 0-terminated string. If \fI*buffer\fR isn't NULL and \fIc\fR is 0, \fI*buffer\fR will be
returned. If you want to create a new string that is empty then \fI*buffer\fR must be NULL and \fIc\fR must be 0.
.SH "NOTES"
You should always proofe that the functions doesn't return NULL. \fIss_errno\fR is declared in the libraray and doesn't need to
be declared by yourself, just use it. Like errno from errno.h you must se it to SS_NO_ERROR by yourself (when SS_NO_ERROR is a posible
value when the returning pointer is NULL).

You must always free you buffers by yourself, don't forget it!

Read \fBsstrings\fR(5) for a list of the constants.
.SH "EXAMPLE"
.RS
.nf
	#include <stdio.h>
	#include <sstrings.h>

	int main(void)
	{
		char* line = NULL, *tmp;
		int c;
		while('\\n' != (c = getc(stdin)))
		{
			ss_errno = SS_NO_MEM;
			tmp = addchar(&line, c);

			if(!tmp)
			{
				/* posible values: 1. SS_NULL_BUFFER
				   but this value is imposible,
				   2. SS_NO_MEM */

				fprintf(stderr, "You don't have enough memory\\n");
				free(line);
				return 1;
			}

			line = tmp; /* if tmp != line then the old content if line was free'ed by addchar */

		}

		printf("The line you input: %s\\n", line);

		free(line); /* DON'T FORGET THIS */

		return 0;
	}
.fi
.RE
.SH "BUGS"
I don't know about any bugs. But I would be very happy to know one if you find one. Please report bugs at
pabloy@pcpool.mathematik.uni-freiburg.de
.SH "SEE ALSO"
.BR appendstring (3)
.BR appendnstring (3)
.BR stringappend (3)
.BR stringnappend (3)
.BR str2sstr (3)
